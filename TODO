-*- org -*-
#+FILETAGS: :mathmap:
**Windows
* 1.3.5
**Windows
** Windows
*** TODO why does syntax highlighting not work completely in WinGimp? 	:bug:
**Windows
** General
**Category
** Packaging
*** TODO check out Robin Norwood's spec file changes (for Fedora)
*** TODO update homepage 				      :documentation:
** Compiler
*** DONE We still have some bugs in the coordinate transformations	:bug:
    CLOSED: [2009-08-16 Sun 23:17]
    This does not work as expected if the aspect ratios of in1 and in2
    are different:

    #+BEGIN_SRC mathmap
    filter bla_ident (image in)
      in(xy)
    end

    filter bla (image in, image in2)
      bla_ident(in2,xy)
    end
    #+END_SRC

    It turns out the problem here is that closures get their pixel
    size from their first image, which is wrong.  It should always be
    the same for all closures, namely the canvas size.
*** DONE Profile the compilation of Gaussian Blur->Spin Zoom->Droste :performance:
    CLOSED: [2009-08-16 Sun 00:24]
    Most of the time is spent in GCC compiling the C code.  Without
    the backend we compile in 0.4s, with the GCC backend in over 3s.
    Just compiling the C code on the command-line takes about 2.5s.
    With LLVM we're much faster - about 0.8s including the backend.
*** DONE Gaussian Blur->Droste still has some loop issues		:bug:
    CLOSED: [2009-08-15 Sat 22:16]
Will be solved by [[*caching of native filter results]].
*** DONE Gaussian Blur->Spin Zoom->Droste crashes			:bug:
    CLOSED: [2009-08-15 Sat 22:59]
So does Gaussian Blur->Random Blur->Droste

* 1.3.x

** GIMP Plug-In
*** TODO We have a one-pixel offset between fast and slow preview again :bug:
    Just try ident filter and turn fast preview on and off.
*** TODO MathMap crashes if a drawable is selected that was already closed in GIMP :bug:
*** TODO speed up rendering of GIMP drawables by processing tile for tile :performance:
*** TODO make preview input drawables to be floatmaps		      :simplify:
*** TODO UI via GtkBuilder/Glade				      :simplify:

** General
*** TODO =tree_vector_node_t= shouldn't be a union - don't alloc a pointer array for the leaves  :performance:
*** TODO move everything from invocation to frame that belongs there  :simplify:
*** TODO pass through frame and t everwhere				   :bug:
*** TODO use -O3						   :performance:
*** TODO do we need uservals, image size in invocation when we have them in the closure? :simplify:

** Language
*** TODO builtin == for tuples of length >1			       :feature:
    we'll need additional features for that in builtins.lisp
*** TODO builtin for getting size of an image			       :feature:
*** TODO real gamma function buggy					   :bug:
*** TODO check out LCH color space
    http://github.com/schani/mathmap/issues/#issue/3
*** TODO sqrt for complex					       :feature:

** Compiler
*** TODO Loop-invariant code motion does not honor non-pure ops		:bug:
*** TODO We put loops into const code even if they're not necessary 	:bug:
For example, Gaussian Blur->Random Blur without loop invariant code
motion.
*** TODO We need something to handle loop-invariant conditional closures :bug:
Obsoleted by [[*caching of native filter results]].

Consider this code:

#+BEGIN_SRC mathmap
while ... do
  cond = ...;
  if cond then
    img = gaussian_blur(abc)
  else
    img = gaussian_blur(def)
  end;
  p = img(xy)
end
#+END_SRC

If =cond= is not loop-invariant then we cannot move the =if= statement
out of the loop, and neither of the invocations of =gaussian_blur=,
which means that for every pixel we will render either one or the
other.

We need a lazy evaluation operation that makes sure that the rendering
happens only once.  Something that transforms the above code to:

#+BEGIN_SRC mathmap
img_true = lazy(gaussian_blur(abc));
img_false = lazy(gaussian_blur(def));
while ... do
  cond = ...;
  if ... then
    img = force(img_true)
  else
    img = force(img_false)
  end;
  p = img(xy)
end
#+END_SRC

The =lazy= operation would create a kind of closure which =force=
would invoke at most once and then store and reuse the result.  Of
course =lazy= would only be used for expensive operations.
*** TODO number*image must trigger an error!				   :bug:
    This means that the compiler will have to know about types other
    than tuples.
*** TODO Make exprtree and scanner use compiler pools as well	      :simplify:
*** TODO Generator for simplifiers				      :simplify:
*** TODO Simplify coordinate stuff (non-stretched ident filter) :performance:feature:
*** TODO calculate R in the filter code				      :simplify:
*** TODO optimize =IMAGE_PIXEL_WIDTH/HEIGHT(closure)= 		:performance:
*** TODO replace resize with a simple internal filter		      :simplify:
*** TODO don't use =x_consts= and =y_consts= structs in =filter_func=
*** TODO make two different =filter_XXX= functions 		:performance:
    one for calling in closure, one without closure, so as not to require building the closure
*** TODO make solve ops and ell-jac foldable, also tuple-nth, tree-vector-nth :performance:
    requires pools in the folders
*** TODO make internals typed
*** TODO don't produce functions for filters which have been optimized away :performance:
*** TODO short circuit execution for =&&= etc in compiler  :feature:performance:

** LLVM
*** TODO implement mathfuncs				  :performance:simplify:
*** TODO pass t properly (test with recursive filters)			   :bug:
*** TODO remove pools in root closure image once mathfuncs work	      :simplify:
*** TODO implement comparison ops with float args		   :performance:
    we only have comparison ops with float args, so we always promote ints, even in loops:

#+BEGIN_SRC mathmap
filter loop ()
  g = 0;
  for i = 0 .. 10 do
    g = g + (x + y)/30
  end;
  grayColor(g)
end
#+END_SRC
** Packaging
*** TODO Generate keyword list in sourceview spec file from builtins.lisp :simplify:
*** TODO rewrite HACKING and include it in distro		 :documentation:

** Testing
*** TODO make random function testable
*** TODO missing test cases

** Rendering
*** TODO strip resize images manually		       :performance:simplify:
    We don't strip resize, so we take the slow rendering path.  This
    would be obsolete if we used a [[*replace resize][filter for resizing]].
*** TODO specifiable size					    :feature:
*** TODO antialiasing from rendered images			    :feature:
*** TODO do rendering multi-threaded if possible		:performance:

** Designer
*** TODO native filters should show up directly, without .mm filters
    really? - why?
*** TODO do migration with save/load				   :simplify:
*** TODO free =widget_data= in designs 					:bug:
*** TODO akklimatisierungsbug (bertl)					:bug:
    When loading a composition and then switching to the composer
    view, the edges are wrong first and then jump into the correct
    configuration.
*** TODO when bigger fonts are used the nodes look funny		:bug:

** Filters
*** TODO sharp blur						    :feature:
*** TODO math filters with constants for composer		    :feature:
*** TODO better layer modes: http://pegtop.net/delphi/articles/blendmodes/ :feature:
*** TODO color gimp layer mode					    :feature:

** Native filters
*** TODO We're superfluously copying floatmaps in Gauss 	:performance:
When Gauss isn't given a floatmap, it renders it into a new floatmap,
and then that floatmap is copied again.
*** TODO Images in the native filter cache are never freed		:bug:
Use some form of reference counting.
*** TODO figure out how much faster 2^n ffts are		:performance:
*** TODO do gaussian multithreaded if possible			:performance:
*** TODO see if there are faster gauss implementations available (some intel stuff?) :performance:
*** TODO take aspect ratio of kernel into consideration - don't stretch it
*** TODO normalize argument for convolve should not be bool but be the value to normalize to :feature:
*** TODO image segmentation					    :feature:
*** TODO edge detection						    :feature:

** Command Line Tool
*** TODO Report error positions					    :feature:
*** TODO Colors as definable user values			    :feature:
*** TODO Make input drawables be floatmaps			   :simplify:

* 1.3.y

** Designer
*** TODO catch and forbid recursive compositions

** GIMP Plug-In
*** TODO auto-completion					    :feature:
*** TODO Histogram						    :feature:
*** TODO ask to save before quitting or selecting another expression or composition
*** TODO Different fast image source size per drawable		    :feature:
    Would be trivial if [[*input drawables to be floatmaps][fast image sources were floatmaps]].
*** TODO Adapt fast image source size to preview size		    :feature:
*** TODO zoom in preview					    :feature:
    Do we really need this?
*** TODO Get preview background gray from GtkStyle		  :cosmetics:
*** TODO figure out how to pass user values to gimp so that Filters->Repeat works properly :feature:
    We can do this by encoding them in a string.

** Language
*** TODO provide syntactic sugar for returning images instead of colors :feature:
*** TODO indirectly recursive filters				    :feature:
*** TODO Hypercomplex-Complex multiplication			    :feature:
*** TODO XYZ, Lab color space support				    :feature:
*** TODO filters as first class values				    :feature:

** General
*** TODO Logarithmic sliders					    :feature:
*** TODO Debug tuples						    :feature:
*** TODO Remove i18n?						   :simplify:

** Rendering
*** TODO lazy rendering						:performance:

** Packaging
*** TODO Real dependencies

** Compiler
*** TODO check why lots of ops (like =RED_FLOAT=) are not foldable  :performance:
*** TODO pass colors as tuples					   :simplify:
*** TODO more arithmetic optimizations (like a*c1+a*c2 -> a*(c1+c2)) :performance:
    Implement [[*Generator for simplifiers][simplifier generator]] first.
*** TODO catch duplicate filter names					:bug:
*** TODO passing of colors, curves and gradients to filters	    :feature:
*** TODO filter call argument checking					:bug:
*** TODO optimization for filters which use the "current" pixel :performance:
*** TODO Remove dead whiles					:performance:
*** TODO don't use const vars for int/float constants
    What does that mean?

* long term

** GIMP Plug-In
*** TODO Preview in thread					    :feature:
*** TODO UI names for user values				    :feature:

** General
*** TODO Edge behaviour as image attributes			    :feature:

* probably never

** Blender
*** TODO noise, gamma, vector/matrix division do not work
*** TODO edge behaviour is not implemented
*** TODO antialiasing and supersampling are not implemented

* Ideas for world domination

** Make MathMap create plug-ins for GStreamer

** GEGL

*** MathMap could create plug-ins for GEGL
*** MathMap could optimize GEGL graphs

    We could take a GEGL graph, and if we have MathMap filters for all
    the filters in the graph involved, we can create one single
    MathMap filter that does the work of the whole graph and should be
    much faster.

* Links

  http://www.sf.edu/jhlavacek/gallery.html
  http://www.mai.liu.se/~halun/complex/complex.html
  http://www.ukuug.org/events/linux2001/papers/html/TRathborne_mathmap-fractals/Paper.html

* Various filters

** Konrad Stania
#+BEGIN_SRC mathmap
winkelrotz=0;
winkelrothor=0;
shiftx=0;
shifty=0;
fa=1;
fb=0;
fc=0;
fd=0;
rotmz=m3x3:[cos(-winkelrotz),-sin(-winkelrotz),0,sin(-winkelrotz),cos(-winkelrotz),0,0,0,1];
rotmh=m3x3:[1,0,0,0,cos(-winkelrothor),-sin(-winkelrothor),0,sin(-winkelrothor),cos(-winkelrothor)];
focus=max(X,Y)*5;
rad=r/R;
trafomat=rotmz*rotmh;
koord1ra=ra:[R*(fa*rad+fb*rad^2+fc*rad^3+fd*rad^4),a];
koord1x=nil:[koord1ra[0]*cos(koord1ra[1])];
koord1y=nil:[koord1ra[0]*sin(koord1ra[1])];
koord1z=0;
koordtraf=[koord1x,koord1y,koord1z]*trafomat;
origValXY(koordtraf[0]/(koordtraf[2]+focus)*focus-X*shiftx,koordtraf[1]/(koordtraf[2]+focus)*focus-Y*shifty)


Remarks:
winkelrotz   : rotate the image (clockwise)
winkelrothor : perspectively tilt the image around horizont.
               In architectural fotography used to make vertical lines strictly paralell
shiftx/shifty: shift the resulting imgae
fa ... fd    : to scale image and remove optical distortion
               in polar koordinates radius = fa * radius + fb * radius ^ 2 + fc * radius ^ 3 + fd * radius ^ 4
#+END_SRC
** make vertically seamless
#+BEGIN_SRC mathmap
# Thanks to Martin Weber
origValXY(x,y-sign(y)*Y)*abs(y)/Y+origVal(xy)*(1-(abs(y)/Y))
#+END_SRC
** make horizontally seamless
#+BEGIN_SRC mathmap
# Thanks to Martin Weber
origValXY(x-sign(x)*X,y)*abs(x)/X+origVal(xy)*(1-(abs(x)/X))
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
g = user_slider("granularity",0,50);
nxy = xy/R*g;
n = noise3([nxy[0],nxy[1],t*g]);
grayColor(n)*0.5+0.5
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
g = user_slider("granularity",0,50);
nxy = xy/R*g;
point = [nxy[0],nxy[1],t*g];
offset = (point + 0.5) / user_slider("offset granularity",0,50);
n1y = user_slider("n1y",0,10);
n1z = user_slider("n1z",0,10);
offset = [noise1(offset[0]),noise1(offset[1]),noise1(offset[2])] * user_slider("distortion",0,10);
#grayColor(offset[0]*0.5+0.5)
n = noise3(point+offset);
grayColor(n)*0.5+0.5
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
dx=-5;
dy=-5;
sum=rgba:[0,0,0,0];
num=0;
while dy < 6 do
    while dx < 6 do
        sum = sum + origVal(xy+xy:[dx,dy]);
        num = num + 1;
        dx = dx + 1
    end;
    dy = dy + 1
end;
sum / num
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
alpha = user_slider("alpha",0,360);
dir = xy:[cos(alpha),sin(alpha)];
ndir = xy:[-dir[1],dir[0]];
p = xy / m2x2:[dir[0],-ndir[0],
               dir[1],-ndir[1]];
pt = dir * p[0];
vec = xy - pt;
dist = -p[1] / R;
pos = 0.5 + p[0] / R / 2;
lower = user_curve("lower",pos) * 2 - 0.5;
upper = user_curve("upper",pos) * 2 - 0.5;
f = ((dist + 1) / 2 - lower) / (upper - lower);
origVal(pt + ndir * (f*2-1) * )R
#+END_SRC
** Fractal Noise
#+BEGIN_SRC mathmap
z = user_slider("z",0,10);
depth = floor(user_slider("depth",1,10));
pers = user_slider("persistence",0,1);
g = user_slider("granularity",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = 0;
max = 0;
while i < depth + 1 do
    sum = sum + noise(xyz*i) * (pers^i);
    max = max + (pers ^ i);
    i = i + 1
end;
grayColor(sum / (max * 2) + 0.5)
#+END_SRC
** Fractal Noise Displace
#+BEGIN_SRC mathmap
z = user_float("z",0,10);
depth = user_int("depth",1,10);
pers = user_float("persistence",0,1);
g = user_float("granularity",0,50);
strength = user_float("strength",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = xy:[0,0];
max = 0;
while i < depth + 1 do
    persi = pers ^ i;
    sum = sum + xy:[noise(xyz*i),noise(xyz*i+[3.1415,2.71234,5.4322])] * persi;
    max = max + persi;
    i = i + 1
end;
val = sum / max;
origVal(xy + val * strength)
#+END_SRC
** Smooth Mugl
#+BEGIN_SRC mathmap
sl=30;
nx=floor(x/sl-0.5); ny=floor(y/sl-0.5);
alpha=[0,0,0,0];
radii=[0,0,0,0];
phii=[0,0,0,0];
xc=[0,0,0,0];
yc=[0,0,0,0];
heuslfaktor=sl/user_slider("size",1.2,5);
i=0; while i < 4 do
    ix=nx+i%2;
    iy=ny+floor(i/2);
    xc[i]=(ix+0.5)*sl;
    yc[i]=(iy+0.5)*sl;
    alpha[i]=(noise([ix*0.3,iy*0.3,0])+1)*180+t*360;
    kurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,pmod(alpha[i],360)];
    phii[i]=kurde[1];
    radii[i]=heuslfaktor*(1+noise([xc[i]+cos(kurde[1]),yc[i]+sin(kurde[1]),0]*2)*0.7);
    i = i + 1
end;
i=0;found=0;
while !found && i<4 do
    heuslkurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,alpha[i]];
    if heuslkurde[0]<radii[i] then
        found = 1
    else
        i=i+1
    end
end;
if i >= 4 then
    rgba:[0,0,1,1]
else
    if heuslkurde[0] < radii[i]-1.5 then
        origVal(toXY(heuslkurde)+xy:[xc[i],yc[i]])
    else
        rgba:[0,0,0,1]
    end
end
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
dur = user_slider("duration",0,5);
amp = exp(-t / dur);
front = t * R * 2;
dropxy = xy:[0,0];
dropr = toRA(xy - dropxy)[0];
disp = sin(dropr * 360 / user_slider("length",0,100) + t * 360 * user_slider("speed",0,100)) * cos(clamp(if front == 0 then 90 else dropr/front end * 90,0,90))^2 * user_slider("amp",0,100) * amp;
dispxy = toXY(ra:[disp,0]);
origVal(xy+dispxy)
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
dur = user_slider("duration",0,5);
amp = exp(-t / dur);
front = t * R * 2;
n = user_slider("num drops",1,20);
lastt = user_slider("t of last drop",0,1);
i = 0;
dispxy = xy:[0,0];
while i < n do
    dropt = scale(noise([n * pi, 0 * pi, 0]),-1,1,0,lastt);
    dropxy = xy:[noise([n * pi, pi, 0]),noise([n * pi, 2 * pi, 0])] * XY;
    dropr = (toRA(xy - dropxy))[0];
    disp = sin(dropr * 360 / user_slider("length",0,100) + t * 360 * user_slider("speed",0,100)) * cos(clamp(if front == 0 then 90 else dropr/front end * 90,0,90))^2 * user_slider("amp",0,100) * amp;
    dispxy = dispxy + toXY(ra:[disp,0]);
    i = i + 1
end;
origVal(xy+dispxy)
#+END_SRC
** Frame Diff
#+BEGIN_SRC mathmap
(origVal(xy,frame)-origVal(xy,frame-1))/2+rgba:[1/2,1/2,1/2,1]
#+END_SRC
** Fade
#+BEGIN_SRC mathmap
origVal(xy,image:0,frame)*(1-t)+origVal(xy,image:1,frame)*t
#+END_SRC
** Movie Spiral
#+BEGIN_SRC mathmap
q=sin((r-a*0.1)*10+t*5*360)*0.5+0.5;
origVal(xy,image:0,frame)*(1-q)+origVal(xy,image:1,frame)*q
#+END_SRC
** Slide (left->right) Transition
#+BEGIN_SRC mathmap
if (x+X)/W < t then origVal(xy,image:0,frame) else origVal(xy,image:1,frame) end
#+END_SRC
** Unknown
#+BEGIN_SRC mathmap
st=15;p=clamp((x+X-t*W)/st+0.5,0,1);origVal(xy,image:0,frame)*(1-p)+origVal(xy,image:1,frame)*p
#+END_SRC
** Craig Kaplan

Okay.  Well, part of the talk was about how some of Escher's
patterns with shapes that diminish towards the centre of the
plane are just mathematical transformations of simple
Euclidean patterns.  I demonstrated this fact by carrying
the transformation out on a couple of patterns.  You can see
the results here:

        http://www.cgl.uwaterloo.ca/~csk/tmp/butterflies.png
        http://www.cgl.uwaterloo.ca/~csk/tmp/butterflies_merc.png
        http://www.cgl.uwaterloo.ca/~csk/tmp/snakes.jpg
        http://www.cgl.uwaterloo.ca/~csk/tmp/snakes_merc.png

For reference, the transformation is to put the coordinate 
axes of the complex plane at the center of the circular picture
and to pass the image through the function f(z)=log(z) in
the complex plane.  More precisely, I used this function in 
MathMap:

#+BEGIN_SRC mathmap
y = y/H*360.0*1.6;
cy = cos( ay );
sy = sin( ay );
ax =-0.8+(x+X)/W*9;
ex = exp( ax );
mx = ex*cy;
my = ex*sy;

ssx = mx*3;
ssy = my*3;

origVal( xy:[ssx+4,ssy-1] )
#+END_SRC
* Language extension ideas
#+BEGIN_SRC mathmap
defun map ((nil:1)->nil:1 f, _:_ x)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i]) end)
end

defun map ((nil:1, nil:1)->nil:1 f, T:L x, T:L y)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i],y[i]) end)
end

defun __add (ri:2 a, ri:2 b)
    ri:[a[0]+b[0],a[1]+b[1]]
end

defun __add (T:L a, _:1 b)
    map(lambda (nil:1 x) x+b end, a)
end

defun __add (T:L a, T:L b)
    map(lambda (nil:1 x, nil:1 y)
            x+y
        end, a, b)
end

defun __mul (ri:2 a, ri:2 b)
    ri:[a[0]*b[0] - a[1]*b[1], a[0]*b[1] + b[0]*a[1]]
end

defun __div (ri:2 a, ri:2 b)
    if b == ri:[0,0] then
        ri:[0,0]
    else
        q = b[0] * b[0] + b[1] * b[1];
        ri:[(a[0]*b[0] + a[1]*b[1]) / q, (-a[0]*b[1] + b[0]*a[1]) / q]
    end
end
#+END_SRC
* Junk - file properly

unload c code in openstep
library








macos:
gruen fuer ints, floats und konstanten duenkler
"Informational Text" in library?
tool tips
library at startup




manual: WH,W,H statt wh,w,h
koordinatensystem erklaeren


> (i) Die Moeglichkeit, bei 'user_slider(name,minimum,maximum)' als 'maximum'
> und 'minimum' Ausdruecke anzugeben, die von den Variablen 'X(nil:1)' und
> 'Y(nil:1)' abhaengen.
> 
> (ii) Einen voreingestellten Wert fuer 'userslider' festzulegen (mit der
> gleichen Methode wie unter (i)).


macos x:
  movies (realtime!)







gimptool in Makefile statt gimp-config verwenden
radio buttons
NaN und Infty ausprobieren
init optimization
save expression in image




normalisierung von matrizen (matrix/determinante)
inverse matrix
pixel konvertieren schneller machen
abs cool machen (abs([-3,4]) sollt 5 sein, ned [3,4])

#+TITLE:     MathMap TODO
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
